//===----------------------------------------------------------------------===//
// This file is automatically generated by scripts/generate_enums.py
// Do not edit this file manually, your changes will be overwritten
//===----------------------------------------------------------------------===//

#include "vmf_enums.hpp"
#include "duckdb/common/string_util.hpp"

namespace duckdb {

template<>
const char* EnumUtil::ToChars<VMFScanType>(VMFScanType value) {
	switch(value) {
	case VMFScanType::INVALID:
		return "INVALID";
	case VMFScanType::READ_VMF:
		return "READ_VMF";
	case VMFScanType::READ_VMF_OBJECTS:
		return "READ_VMF_OBJECTS";
	case VMFScanType::SAMPLE:
		return "SAMPLE";
	default:
		throw NotImplementedException(StringUtil::Format("Enum value of type VMFScanType: '%d' not implemented", value));
	}
}

template<>
VMFScanType EnumUtil::FromString<VMFScanType>(const char *value) {
    if (StringUtil::Equals(value, "INVALID")) {
		return VMFScanType::INVALID;
	}
    if (StringUtil::Equals(value, "READ_VMF")) {
		return VMFScanType::READ_VMF;
	}
    if (StringUtil::Equals(value, "READ_VMF_OBJECTS")) {
		return VMFScanType::READ_VMF_OBJECTS;
	}
    if (StringUtil::Equals(value, "SAMPLE")) {
		return VMFScanType::SAMPLE;
	}
   throw NotImplementedException(StringUtil::Format("Enum value of type VMFScanType: '%s' not implemented", value));
}

template<>
const char* EnumUtil::ToChars<VMFRecordType>(VMFRecordType value) {
	switch(value) {
	case VMFRecordType::AUTO_DETECT:
		return "AUTO_DETECT";
	case VMFRecordType::RECORDS:
		return "RECORDS";
	case VMFRecordType::VALUES:
		return "VALUES";
	default:
		throw NotImplementedException(StringUtil::Format("Enum value of type VMFRecordType: '%d' not implemented", value));
	}
}

template<>
VMFRecordType EnumUtil::FromString<VMFRecordType>(const char *value) {
    if (StringUtil::Equals(value, "AUTO_DETECT")) {
		return VMFRecordType::AUTO_DETECT;
	}
    if (StringUtil::Equals(value, "RECORDS")) {
		return VMFRecordType::RECORDS;
	}
    if (StringUtil::Equals(value, "VALUES")) {
		return VMFRecordType::VALUES;
	}
   throw NotImplementedException(StringUtil::Format("Enum value of type VMFRecordType: '%s' not implemented", value));
}

template<>
const char* EnumUtil::ToChars<VMFFormat>(VMFFormat value) {
	switch(value) {
	case VMFFormat::AUTO_DETECT:
		return "AUTO_DETECT";
	case VMFFormat::UNSTRUCTURED:
		return "UNSTRUCTURED";
	case VMFFormat::NEWLINE_DELIMITED:
		return "NEWLINE_DELIMITED";
	case VMFFormat::ARRAY:
		return "ARRAY";
	default:
		throw NotImplementedException(StringUtil::Format("Enum value of type VMFFormat: '%d' not implemented", value));
	}
}

template<>
VMFFormat EnumUtil::FromString<VMFFormat>(const char *value) {
    if (StringUtil::Equals(value, "AUTO_DETECT")) {
		return VMFFormat::AUTO_DETECT;
	}
    if (StringUtil::Equals(value, "UNSTRUCTURED")) {
		return VMFFormat::UNSTRUCTURED;
	}
    if (StringUtil::Equals(value, "NEWLINE_DELIMITED")) {
		return VMFFormat::NEWLINE_DELIMITED;
	}
    if (StringUtil::Equals(value, "ARRAY")) {
		return VMFFormat::ARRAY;
	}
   throw NotImplementedException(StringUtil::Format("Enum value of type VMFFormat: '%s' not implemented", value));
}

} // namespace duckdb
